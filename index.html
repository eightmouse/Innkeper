<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Innkeeper</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Exo+2:wght@300;400;500;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<div id="app">

  <div id="titlebar">
    <div id="titlebar-left">
      <img id="titlebar-logo" src="logo.png" alt="Innkeeper" />
      <span id="titlebar-title">INNKEEPER</span>
      <div id="menubar">
        <div class="menu-item" id="menu-settings">Settings</div>
        <div class="menu-item" id="menu-info">Info</div>
      </div>
    </div>
    <div id="window-controls">
      <button class="win-btn min" id="btn-min" title="Minimize">
        <svg width="11" height="1" viewBox="0 0 11 1"><line x1="0" y1="0.5" x2="11" y2="0.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/></svg>
      </button>
      <button class="win-btn max" id="btn-max" title="Maximize">
        <svg width="10" height="10" viewBox="0 0 10 10"><rect x="0.6" y="0.6" width="8.8" height="8.8" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linejoin="round"/></svg>
      </button>
      <button class="win-btn close" id="btn-close" title="Close">
        <svg width="10" height="10" viewBox="0 0 10 10"><line x1="0.5" y1="0.5" x2="9.5" y2="9.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/><line x1="9.5" y1="0.5" x2="0.5" y2="9.5" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>
      </button>
    </div>
  </div>

  <div id="content">
    <div id="empty-state">
      <div class="empty-icon">‚öîÔ∏è</div>
      <p>No characters yet ‚Äî click + to add one</p>
    </div>
    <div id="character-grid"></div>
  </div>

</div>

<button id="add-btn" title="Add Character">+</button>

<!-- ‚îÄ‚îÄ Add Character Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="add-modal" class="modal-overlay">
  <div class="modal">
    <h2>Add Character</h2>
    <div class="form-group">
      <label>Character Name</label>
      <input type="text" id="input-name" placeholder="e.g. Arthas" autocomplete="off" />
    </div>
    <div class="form-group">
      <label>Realm <span class="label-hint">(leave blank to search all)</span></label>
      <div class="autocomplete-wrap">
        <input type="text" id="input-realm" placeholder="e.g. Silvermoon" autocomplete="off" />
        <div id="realm-dropdown" class="autocomplete-dropdown"></div>
      </div>
    </div>
    <div class="form-group">
      <label>Region</label>
      <select id="input-region">
        <option value="eu">EU</option>
        <option value="us">US</option>
        <option value="kr">KR</option>
        <option value="tw">TW</option>
      </select>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" id="modal-cancel">Cancel</button>
      <button class="btn btn-primary" id="modal-submit">Search & Add</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Delete Confirm Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="delete-modal" class="modal-overlay">
  <div class="modal">
    <h2>Remove Character</h2>
    <p id="delete-modal-msg" style="font-size:13px;color:var(--text-muted);margin-bottom:20px;line-height:1.5;"></p>
    <div class="modal-actions">
      <button class="btn btn-secondary" id="delete-cancel">Cancel</button>
      <button class="btn btn-danger" id="delete-confirm">Remove</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Info Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="info-modal" class="modal-overlay">
  <div class="modal">
    <h2>About Innkeeper</h2>
    <div class="info-body">
      <p class="info-line">A World of Warcraft app to keep track of your characters</p>
      <div class="info-divider"></div>
      <div class="info-row"><span class="info-label">Author</span><span class="info-value">Eightmouse</span></div>
      <div class="info-row">
        <span class="info-label">GitHub</span>
        <a class="info-link" id="github-link" href="https://github.com/eightmouse">github.com/eightmouse</a>
      </div>
      <div class="info-row"><span class="info-label">Version</span><span class="info-value">0.9</span></div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" id="info-close">Close</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Settings Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="settings-modal" class="modal-overlay">
  <div class="modal">
    <h2>Settings</h2>
    <div class="settings-body">
      <div class="setting-row">
        <div class="setting-label">Theme</div>
        <div class="theme-buttons">
          <button class="theme-btn active" data-theme="dark">Dark</button>
          <button class="theme-btn" data-theme="light">Light</button>
        </div>
      </div>
    </div>
    <div class="modal-actions">
      <button class="btn btn-secondary" id="settings-close">Close</button>
    </div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Character Detail Modal (Armory-style) ‚îÄ‚îÄ‚îÄ‚îÄ -->
<div id="detail-overlay" class="modal-overlay">
  <div id="detail-modal">

    <!-- Header bar -->
    <div class="detail-header">
      <div class="detail-header-avatar" id="detail-avatar"></div>
      <div class="detail-header-info">
        <div class="detail-name" id="detail-name">‚Äî</div>
        <div class="detail-sub" id="detail-sub">‚Äî</div>
      </div>
      <button class="detail-close" id="detail-close">
        <svg width="10" height="10" viewBox="0 0 10 10"><line x1="0.5" y1="0.5" x2="9.5" y2="9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="9.5" y1="0.5" x2="0.5" y2="9.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
      </button>
    </div>

    <!-- Tab bar -->
    <div class="detail-tabs">
      <button class="detail-tab active" data-tab="equipment">Equipment</button>
      <button class="detail-tab" data-tab="talents">Talents</button>
      <button class="detail-tab" data-tab="vault">Vault</button>
      <button class="detail-tab" data-tab="professions">Professions</button>
    </div>

    <!-- Body: tab content panels -->
    <div class="detail-body">

      <!-- Equipment Tab (default) -->
      <div class="detail-tab-panel active" id="panel-equipment">
        <!-- LEFT: Activities & Reset timers -->
        <div class="detail-left">
          <div class="detail-section-title">Activities</div>
          <div id="detail-activities"></div>

          <div class="reset-info">
            <div class="detail-section-title" style="border:none;padding:0;margin-bottom:8px;">Reset Timers</div>
            <div class="reset-row">
              <span class="reset-label">Daily</span>
              <span class="reset-value" id="reset-daily">‚Äî</span>
            </div>
            <div class="reset-row">
              <span class="reset-label">Weekly</span>
              <span class="reset-value" id="reset-weekly">‚Äî</span>
            </div>
          </div>
        </div>

        <!-- RIGHT: Armory view (equip-left | portrait | equip-right) -->
        <div class="detail-right">
          <div class="armory-view">
            <div class="equip-col equip-left" id="equip-left"></div>
            <div class="armory-portrait" id="armory-portrait">
              <div class="armory-loading" id="armory-loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading gear‚Ä¶</div>
              </div>
              <div class="equip-refresh-indicator" id="equip-refresh-indicator">
                <div class="refresh-spinner"></div>
                <div class="refresh-text">Checking for changes‚Ä¶</div>
              </div>
            </div>
            <div class="equip-col equip-right" id="equip-right"></div>
          </div>
        </div>
      </div>

      <!-- Talents Tab -->
      <div class="detail-tab-panel" id="panel-talents">
        <div class="talent-container">
          <div class="talent-sidebar">
            <h3 class="talent-sidebar-title">Build Presets</h3>
            <div class="build-preset-list" id="build-presets"></div>
            <div class="talent-actions">
              <button class="wowhead-link" id="copy-talents-btn">
                <svg width="12" height="12" viewBox="0 0 16 16" fill="none">
                  <rect x="5" y="5" width="8" height="8" rx="1.5" stroke="currentColor" stroke-width="1.3"/>
                  <path d="M3 11V3h8" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
                </svg>
                <span>Copy Talents</span>
              </button>
              <div class="copy-talents-toast" id="copy-talents-toast">Copied!</div>
            </div>
          </div>
          <div class="talent-tree-view" id="talent-tree-view">
            <!-- Tree sections rendered by JS -->
          </div>
        </div>
      </div>

      <!-- Vault Tab -->
      <div class="detail-tab-panel" id="panel-vault">
        <div class="tab-content-full">
          <div class="vault-content" id="vault-content">
            <div class="vault-placeholder">Vault data coming soon...</div>
          </div>
        </div>
      </div>

      <!-- Professions Tab -->
      <div class="detail-tab-panel" id="panel-professions">
        <div class="tab-content-full">
          <div class="professions-content">
            <div class="vault-placeholder">Profession tracking coming soon...</div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<div id="toast"></div>
<div id="talent-fetch-notify"></div>

<script>
'use strict';

let ipcRenderer;
try { ({ ipcRenderer } = require('electron')); }
catch (e) { console.warn('No Electron IPC'); }

const _fs   = typeof require !== 'undefined' ? require('fs')   : null;
const _path = typeof require !== 'undefined' ? require('path') : null;

function escapeHtml(str) {
  if (str == null) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function sendToPython(cmd) {
  if (ipcRenderer) ipcRenderer.send('to-python', cmd);
  else console.log('[‚Üí Python mock]', cmd);
}

let characters    = [];
let detailIndex   = null;
let pendingDelete = null;
const realmCache  = {};

const ACTIVITY_META = {
  'Raid':         { icon: 'https://render.worldofwarcraft.com/us/icons/56/inv_misc_head_dragon_01.jpg' },
  'Mythic+':      { icon: 'https://render.worldofwarcraft.com/us/icons/56/achievement_bg_wineos_underxminutes.jpg' },
  'Expeditions':  { icon: 'https://render.worldofwarcraft.com/us/icons/56/spell_nature_eyeofthestorm.jpg' },
  'World Quests': { icon: 'https://render.worldofwarcraft.com/us/icons/56/quest_khadgar.jpg' },
};

// WoW item quality colors
const QUALITY_COLOR = {
  POOR:      '#9d9d9d',
  COMMON:    '#e8e8e8',
  UNCOMMON:  '#1eff00',
  RARE:      '#0070dd',
  EPIC:      '#a335ee',
  LEGENDARY: '#ff8000',
  ARTIFACT:  '#e6cc80',
  HEIRLOOM:  '#00ccff',
};

// Armory slot layout ‚Äî left col top-to-bottom, right col top-to-bottom
const EQUIP_LEFT  = ['HEAD','NECK','SHOULDER','BACK','CHEST','SHIRT','TABARD','WRIST'];
const EQUIP_RIGHT = ['HANDS','WAIST','LEGS','FEET','RING_1','RING_2','TRINKET_1','TRINKET_2'];
const SLOT_LABEL  = {
  HEAD:'Head', NECK:'Neck', SHOULDER:'Shoulder', BACK:'Back',
  CHEST:'Chest', SHIRT:'Shirt', TABARD:'Tabard', WRIST:'Wrist',
  HANDS:'Hands', WAIST:'Waist', LEGS:'Legs', FEET:'Feet',
  RING_1:'Ring', RING_2:'Ring', TRINKET_1:'Trinket', TRINKET_2:'Trinket',
  MAIN_HAND:'Main Hand', OFF_HAND:'Off Hand', TWOHANDED:'Two-Hand',
};

// Per-class atmospheric card backgrounds ‚Äî [gradient, symbol emoji]
const CLASS_BG = {
  1:  ['radial-gradient(ellipse at 50% 110%, #6b3a10 0%, #2a1006 50%, #0a0402 100%)', '‚öîÔ∏è'],
  2:  ['radial-gradient(ellipse at 50% 110%, #7a5c10 0%, #3a2406 50%, #100a02 100%)', 'üõ°Ô∏è'],
  3:  ['radial-gradient(ellipse at 50% 110%, #183a10 0%, #091e06 50%, #030802 100%)', 'üèπ'],
  4:  ['radial-gradient(ellipse at 50% 110%, #2a2210 0%, #140e04 50%, #060402 100%)', 'üó°Ô∏è'],
  5:  ['radial-gradient(ellipse at 50% 110%, #323232 0%, #1a1a1a 50%, #080808 100%)', '‚ú®'],
  6:  ['radial-gradient(ellipse at 30% 110%, #780e0e 0%, #1c0818 50%, #040210 100%)', 'üíÄ'],
  7:  ['radial-gradient(ellipse at 50% 110%, #0e2a4a 0%, #061422 50%, #02060e 100%)', '‚ö°'],
  8:  ['radial-gradient(ellipse at 50% 110%, #1a0e4a 0%, #0c0828 50%, #03020e 100%)', 'üîÆ'],
  9:  ['radial-gradient(ellipse at 50% 110%, #1c0e3a 0%, #0c0820 50%, #03020a 100%)', 'üî•'],
  10: ['radial-gradient(ellipse at 50% 110%, #0a3018 0%, #051808 50%, #020804 100%)', 'üåø'],
  11: ['radial-gradient(ellipse at 50% 110%, #2a3a08 0%, #141e04 50%, #060802 100%)', 'üçÇ'],
  12: ['radial-gradient(ellipse at 50% 110%, #200a3a 0%, #100420 50%, #04010e 100%)', 'üëÅÔ∏è'],
  13: ['radial-gradient(ellipse at 50% 110%, #083a2a 0%, #041e16 50%, #02080a 100%)', 'üêâ'],
};

function showToast(msg, isError = false) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.className   = 'show' + (isError ? ' error' : '');
  clearTimeout(el._t);
  el._t = setTimeout(() => el.className = '', isError ? 5000 : 2800);
}

function getNextReset(type) {
  const now  = new Date();
  const next = new Date(now);
  next.setUTCHours(8, 0, 0, 0);
  if (type === 'daily') {
    if (now >= next) next.setUTCDate(next.getUTCDate() + 1);
  } else {
    const d = (3 - now.getUTCDay() + 7) % 7 || 7;
    next.setUTCDate(next.getUTCDate() + d);
    if (now.getUTCDay() === 3 && now >= next) next.setUTCDate(next.getUTCDate() + 7);
  }
  return next;
}

function formatTimeUntil(date) {
  const diff = date - Date.now();
  if (diff <= 0) return { text: 'Now', cls: 'now' };
  const h = Math.floor(diff / 3600000);
  const m = Math.floor((diff % 3600000) / 60000);
  return { text: h > 0 ? `${h}h ${m}m` : `${m}m`, cls: h < 2 ? 'soon' : '' };
}

// ‚îÄ‚îÄ Grid ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderGrid() {
  const grid  = document.getElementById('character-grid');
  const empty = document.getElementById('empty-state');
  grid.innerHTML = '';

  if (!characters.length) { empty.classList.add('visible'); return; }
  empty.classList.remove('visible');

  characters.forEach((char, idx) => {
    const card     = document.createElement('div');
    card.className = 'char-card';

    const [gradient, symbol] = CLASS_BG[char.class_id] || ['radial-gradient(ellipse at 50% 110%, #0c1a10 0%, #060e08 100%)', 'üßô'];

    // Layer 1: WoWHead talent background - cover entire card
    // Layer 2: Character render at 210%, centered at Y: 25%
    const hasRender = !!char.portrait_url;
    const hasBg     = char.class_slug && char.spec_slug;
    
    let bgStyle = '';
    if (hasBg && hasRender) {
      const talentBg = `https://wow.zamimg.com/images/tools/dragonflight-talent-calc/blizzard/talentbg-${char.class_slug}-${char.spec_slug}.jpg`;
      bgStyle = `
        background: 
          url('${char.portrait_url}') center 25%/210% no-repeat,
          url('${talentBg}') center/cover no-repeat;
      `;
    } else if (hasBg) {
      const talentBg = `https://wow.zamimg.com/images/tools/dragonflight-talent-calc/blizzard/talentbg-${char.class_slug}-${char.spec_slug}.jpg`;
      bgStyle = `background: url('${talentBg}') center/cover no-repeat;`;
    } else if (hasRender) {
      bgStyle = `background: url('${char.portrait_url}') center 25%/210% no-repeat;`;
    } else {
      bgStyle = `background:${gradient};`;
    }

    const specLine = (char.class_name || char.spec_name)
      ? `<div class="card-spec">${[char.spec_name, char.class_name].filter(Boolean).map(escapeHtml).join(' ¬∑ ')}</div>`
      : '';

    const pips = Object.entries(char.activities || {}).map(([name, data]) =>
      `<div class="activity-pip ${data.status === 'completed' ? 'done' : 'available'}" title="${escapeHtml(name)}"></div>`
    ).join('');

    card.innerHTML = `
      <div class="card-bg" style="${bgStyle}">
        ${!hasBg && !hasRender ? `<div class="class-symbol">${symbol}</div>` : ''}
      </div>
      <button class="card-close" title="Remove">
        <svg viewBox="0 0 8 8" fill="none"><line x1="1" y1="1" x2="7" y2="7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="7" y1="1" x2="1" y2="7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
      </button>
      <div class="card-info">
        <div class="card-name">${escapeHtml(char.name)} <span class="card-level">${escapeHtml(char.level)}</span></div>
        <div class="card-realm">${escapeHtml(char.realm)}</div>
        ${specLine}
        <div class="card-activities">${pips}</div>
      </div>
    `;

    card.querySelector('.card-close').addEventListener('click', e => { e.stopPropagation(); openDeleteModal(idx); });
    card.addEventListener('click', () => openDetail(idx));
    grid.appendChild(card);
  });
}

function updateCardPip(charIdx, activityName, isDone) {
  const card = document.querySelector(`#character-grid .char-card:nth-child(${charIdx + 1})`);
  if (!card) return;
  const keys   = Object.keys(characters[charIdx].activities);
  const pipIdx = keys.indexOf(activityName);
  const pips   = card.querySelectorAll('.activity-pip');
  if (pips[pipIdx]) pips[pipIdx].className = `activity-pip ${isDone ? 'done' : 'available'}`;
}

// ‚îÄ‚îÄ Detail Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function openDetail(idx) {
  detailIndex = idx;
  const char  = characters[idx];
  const [gradient] = CLASS_BG[char.class_id] || ['radial-gradient(ellipse at 50% 110%, #0c1a10 0%, #060e08 100%)'];

  // Header avatar
  const avatarEl = document.getElementById('detail-avatar');
  if (char.avatar_url) {
    avatarEl.style.backgroundImage = `url('${char.avatar_url}')`;
  } else {
    avatarEl.style.backgroundImage = gradient;
  }

  // Header text with item level
  const ilvlText = char.item_level ? ` ¬∑ ilvl ${char.item_level}` : '';
  document.getElementById('detail-name').textContent = `${char.name}${ilvlText}`;
  const subParts = [char.realm, char.class_name, char.spec_name].filter(Boolean);
  document.getElementById('detail-sub').textContent  = subParts.join(' ¬∑ ');

  // Armory portrait with WoWHead talent background spanning full view
  const portrait = document.getElementById('armory-portrait');
  const armoryView = portrait.closest('.armory-view');
  const hasBg    = char.class_slug && char.spec_slug;
  
  if (hasBg) {
    const talentBg = `https://wow.zamimg.com/images/tools/dragonflight-talent-calc/blizzard/talentbg-${char.class_slug}-${char.spec_slug}.jpg`;
    // Full-width gradient for text readability + talent background
    armoryView.style.background = `
      linear-gradient(to right, rgba(6,10,8,0.85) 0%, rgba(6,10,8,0.15) 18%, rgba(6,10,8,0.15) 82%, rgba(6,10,8,0.85) 100%),
      url('${talentBg}') center/cover no-repeat
    `;
    // Center character render in portrait area
    if (char.portrait_url) {
      portrait.style.background = `url('${char.portrait_url}') center 65%/180% no-repeat`;
    } else {
      portrait.style.background = 'transparent';
    }
  } else if (char.portrait_url) {
    armoryView.style.background = 'linear-gradient(to right, rgba(6,10,8,0.85) 0%, rgba(6,10,8,0.15) 18%, rgba(6,10,8,0.15) 82%, rgba(6,10,8,0.85) 100%)';
    portrait.style.background = `url('${char.portrait_url}') center 65%/180% no-repeat`;
  } else {
    armoryView.style.background = '';
    portrait.style.backgroundImage = gradient;
  }
  portrait.style.setProperty('--class-grad', gradient);

  // Activities
  const actList = document.getElementById('detail-activities');
  actList.innerHTML = '';
  Object.entries(char.activities || {}).forEach(([name, data]) => {
    const iconUrl = (ACTIVITY_META[name] || {}).icon;
    const checked = data.status === 'completed';
    const row     = document.createElement('div');
    row.className = 'activity-row';
    row.innerHTML = `
      <div class="activity-row-left">
        ${iconUrl
          ? `<img src="${iconUrl}" class="activity-icon-img" alt="${escapeHtml(name)}" />`
          : `<span class="activity-icon">‚Ä¢</span>`
        }
        <span class="activity-label">${escapeHtml(name)}</span>
        <span class="activity-reset-tag">${escapeHtml(data.reset)}</span>
      </div>
      <label class="toggle">
        <input type="checkbox" ${checked ? 'checked' : ''} />
        <div class="toggle-slider"></div>
      </label>
    `;
    row.querySelector('input').addEventListener('change', e => {
      toggleActivity(idx, name, e.target.checked);
    });
    actList.appendChild(row);
  });

  updateResetTimers();

  // Switch to Equipment tab by default
  switchTab('equipment', char);

  // Show modal, then load equipment
  document.getElementById('detail-overlay').classList.add('open');
  loadEquipment(char);
}

function switchTab(tabName, char) {
  // Update tab button states
  document.querySelectorAll('.detail-tab').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tabName);
  });
  
  // Update panel visibility
  document.querySelectorAll('.detail-tab-panel').forEach(panel => {
    panel.classList.remove('active');
  });
  document.getElementById(`panel-${tabName}`).classList.add('active');

  // Load tab-specific content
  if (tabName === 'talents' && char) {
    loadTalents(char);
  } else if (tabName === 'vault' && char) {
    loadVault(char);
  }
}

// Cache for loaded talent iframes
// ‚îÄ‚îÄ TALENT TREE SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Native talent tree renderer with Blizzard API data + build string decoding.
// Build strings are user-provided (Blizzard export format), stored in talent_builds.json.

const TALENT_TREE_CACHE = {};   // Cached tree data per class/spec
let TALENT_BUILDS = {};          // Build strings per class/spec/type
let _currentTalentChar = null;   // Currently displayed character
let _currentBuildType = 'raid';  // Current active preset
let _talentTooltipEl = null;     // Shared tooltip element
let _talentFetchInProgress = false; // True while talent tree is being fetched
let _equipFetchInProgress = false;  // True while equipment is being fetched

const _activeFetches = {};  // key ‚Üí message, for bottom-right notification

function showFetchNotify(key, msg) {
  _activeFetches[key] = msg;
  _updateFetchNotify();
}

function hideFetchNotify(key) {
  delete _activeFetches[key];
  _updateFetchNotify();
}

function _updateFetchNotify() {
  const el = document.getElementById('talent-fetch-notify');
  const msgs = Object.values(_activeFetches);
  if (msgs.length === 0) {
    el.classList.remove('show');
    return;
  }
  el.innerHTML = msgs.map(m => `<div style="display:flex;align-items:center;gap:8px;"><div class="spinner"></div><span>${m}</span></div>`).join('');
  el.classList.add('show');
}

// ‚îÄ‚îÄ Build String Decoder ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class BitReader {
  constructor(bytes) {
    this.data = bytes;
    this.bitPos = 0;
  }
  read(bits) {
    let val = 0;
    for (let i = 0; i < bits; i++) {
      const byteIdx = this.bitPos >> 3;
      const bitIdx = this.bitPos & 7;
      if (this.data[byteIdx] & (1 << bitIdx)) val |= (1 << i);
      this.bitPos++;
    }
    return val;
  }
  get remaining() { return (this.data.length * 8) - this.bitPos; }
}

function decodeBuildString(exportString, classNodes, specNodes, heroTrees, allNodeIds) {
  /**
   * WoW Talent Export String Decoder (TWW format, LSB-first).
   * Custom base64: each char ‚Üí 6-bit value packed LSB-first into bytes.
   *
   * Header: version(8) + specId(16) + treeHash(128) = 152 bits
   * Then for EACH node (all class+spec IDs sorted, including nodes from other specs):
   *   isSelected (1 bit)
   *   If selected:
   *     isPurchased (1 bit)
   *     If purchased:
   *       isPartiallyRanked (1 bit)
   *       If partial: ranksPurchased (6 bits fixed)
   *       isChoiceNode (1 bit, from stream)
   *       If choice: choiceEntryIndex (2 bits)
   *
   * Uses allNodeIds (full tree) to iterate ALL nodes, not just spec-filtered ones.
   * Active hero tree is determined by which tree has the most selected nodes.
   */
  const result = { selections: {}, activeHeroTreeName: null };
  if (!exportString) return result;

  try {
    // WoW uses a custom base64 where each char is a 6-bit value packed LSB-first into bytes
    const WOW_B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    const str = exportString.trim();
    const totalBits = str.length * 6;
    const bytes = new Uint8Array(Math.ceil(totalBits / 8));
    let bitPos = 0;
    for (const ch of str) {
      const val = WOW_B64.indexOf(ch);
      if (val < 0) continue;
      for (let i = 0; i < 6; i++) {
        if (val & (1 << i)) {
          bytes[bitPos >> 3] |= (1 << (bitPos & 7));
        }
        bitPos++;
      }
    }
    const reader = new BitReader(bytes);

    // Header: version(8) + specId(16) + treeHash(128) = 152 bits
    if (reader.remaining < 152) return result;
    const version = reader.read(8);
    const specId = reader.read(16);
    reader.read(128); // tree hash

    // Build lookup from our spec-filtered nodes
    const nodeMap = {};
    for (const n of classNodes) nodeMap[n.id] = n;
    for (const n of specNodes) nodeMap[n.id] = n;

    // Use the full ordered node ID list (all 208 nodes for DK, etc.)
    // For IDs not in our display data, use a placeholder so bits advance correctly
    let allNodes;
    if (allNodeIds && allNodeIds.length > 0) {
      allNodes = allNodeIds.map(id => nodeMap[id] || { id: 0, max_ranks: 1, type: 'ACTIVE' });
    } else {
      // Fallback: old behavior
      allNodes = [
        ...[...classNodes].sort((a, b) => a.id - b.id),
        ...[...specNodes].sort((a, b) => a.id - b.id),
      ];
    }

    for (const node of allNodes) {
      if (reader.remaining < 1) break;
      const isSelected = reader.read(1);
      if (!isSelected) continue;

      // Blizzard format: isPurchased(1) ‚Üí if purchased: isPartial(1) ‚Üí if partial: rank(6) ‚Üí isChoice(1) ‚Üí if choice: choiceIdx(2)
      const isPurchased = reader.read(1);
      let rank = node.max_ranks || 1;
      let choice = -1;

      if (isPurchased) {
        const isPartial = reader.read(1);
        if (isPartial) {
          rank = reader.read(6); // fixed 6-bit rank
          if (rank === 0) rank = 1;
        }
        const isChoice = reader.read(1);
        if (isChoice) {
          choice = reader.read(2);
        }
      }
      // else: granted (selected but not purchased ‚Äî free node), rank stays at max

      if (node.id !== 0) {
        result.selections[node.id] = { rank, choice };
      }
    }

    // Determine active hero tree by counting which has the most selected nodes
    if (heroTrees && heroTrees.length > 0) {
      let bestTree = null, bestCount = 0;
      for (const ht of heroTrees) {
        if (!ht.nodes) continue;
        const heroIds = new Set(ht.nodes.map(n => n.id));
        const count = Object.keys(result.selections).filter(id => heroIds.has(parseInt(id))).length;
        if (count > bestCount) { bestCount = count; bestTree = ht; }
      }
      if (bestTree) result.activeHeroTreeName = bestTree.name;
    }

    const sel = Object.keys(result.selections).length;
    console.log(`[Talents] Decoded: ${sel} selected, hero=${result.activeHeroTreeName || 'none'}, ${reader.remaining} bits left`);
    return result;
  } catch (e) {
    console.error('[Talents] Decode error:', e);
    return result;
  }
}

// ‚îÄ‚îÄ Tooltip System ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function initTalentTooltip() {
  if (_talentTooltipEl) return;
  _talentTooltipEl = document.createElement('div');
  _talentTooltipEl.className = 'talent-tooltip';
  document.body.appendChild(_talentTooltipEl);
}

function showTalentTooltip(e, node, selections) {
  initTalentTooltip();
  const sel = selections[node.id];
  // Pick the correct entry (for choice nodes, show the selected choice)
  const entryIdx = (sel && sel.choice >= 0) ? sel.choice : 0;
  const entry = node.entries[entryIdx];
  if (!entry) return;

  const rankText = node.max_ranks > 1
    ? `<div class="talent-tooltip-meta">Rank ${sel ? sel.rank : 0}/${node.max_ranks}</div>`
    : '';
  const metaParts = [entry.cast_time, entry.range, entry.cooldown].filter(Boolean);
  const metaHtml = metaParts.length > 0
    ? `<div class="talent-tooltip-meta">${metaParts.join(' ¬∑ ')}</div>`
    : '';

  // For choice nodes, show both options
  let choiceHtml = '';
  if (node.type === 'CHOICE' && node.entries.length > 1) {
    choiceHtml = '<div style="margin-top:8px;padding-top:6px;border-top:1px solid rgba(58,138,80,0.15);font-size:10px;color:var(--text-muted);">';
    node.entries.forEach((ent, i) => {
      const isActive = sel && sel.choice === i;
      const arrow = isActive ? '‚ñ∏ ' : '  ';
      const style = isActive ? 'color:var(--accent);font-weight:600;' : '';
      choiceHtml += `<div style="${style}">${arrow}${escapeHtml(ent.name)}</div>`;
    });
    choiceHtml += '</div>';
  }

  _talentTooltipEl.innerHTML = `
    <div class="talent-tooltip-name">${escapeHtml(entry.name)}</div>
    ${metaHtml}${rankText}
    <div class="talent-tooltip-desc">${escapeHtml(entry.description || '')}</div>
    ${choiceHtml}
  `;
  _talentTooltipEl.classList.add('visible');
  positionTooltip(e);
}

function positionTooltip(e) {
  if (!_talentTooltipEl) return;
  const pad = 12;
  let x = e.clientX + pad;
  let y = e.clientY + pad;
  const rect = _talentTooltipEl.getBoundingClientRect();
  if (x + rect.width > window.innerWidth) x = e.clientX - rect.width - pad;
  if (y + rect.height > window.innerHeight) y = e.clientY - rect.height - pad;
  _talentTooltipEl.style.left = x + 'px';
  _talentTooltipEl.style.top = y + 'px';
}

function hideTalentTooltip() {
  if (_talentTooltipEl) _talentTooltipEl.classList.remove('visible');
}

// ‚îÄ‚îÄ Main: Load Talents ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function loadTalents(char) {
  const view = document.getElementById('talent-tree-view');
  if (!char.class_slug || !char.spec_slug) {
    view.innerHTML = '<div class="talent-empty"><p>Talent data unavailable for this character.</p></div>';
    return;
  }

  _currentTalentChar = char;
  _currentBuildType = 'raid';

  // Set up sidebar
  setupTalentSidebar(char);

  // Check if tree data is cached in memory
  const cacheKey = `${char.class_slug}_${char.spec_slug}`;
  if (TALENT_TREE_CACHE[cacheKey]) {
    renderTalentTree(TALENT_TREE_CACHE[cacheKey], char);
    return;
  }

  // Show loading, fetch from engine
  view.innerHTML = `<div class="talent-loading">
    <div class="loading-spinner"></div>
    <span>Fetching talent tree for ${capitalize(char.spec_slug)} ${capitalize(char.class_slug)}‚Ä¶</span>
    <span style="font-size:10px;color:var(--text-muted);margin-top:4px;">(First load ‚Äî cached after)</span>
  </div>`;
  _talentFetchInProgress = true;
  showFetchNotify('talents', `Fetching ${capitalize(char.spec_slug)} ${capitalize(char.class_slug)} talents‚Ä¶`);
  sendToPython(`FETCH_TALENT_TREE:${char.region}:${char.class_slug}:${char.spec_slug}`);

  // Client-side timeout ‚Äî generous for first load (icon fetching takes time)
  const timeoutId = setTimeout(() => {
    if (_currentTalentChar === char && !TALENT_TREE_CACHE[cacheKey]) {
      _talentFetchInProgress = false;
      hideFetchNotify('talents');
      view.innerHTML = `
        <div class="talent-empty">
          <p>Request timed out.</p>
          <p style="font-size:10px;color:var(--text-muted);margin-bottom:16px;">
            The Blizzard API may be slow or your credentials need checking.<br>
            Check the console (Ctrl+Shift+I) for details.
          </p>
          <button class="btn btn-primary" onclick="loadTalents(_currentTalentChar)">Retry</button>
        </div>`;
    }
  }, 60000);

  // Store timeout so it can be cleared when response arrives
  window._talentLoadTimeout = timeoutId;
}

function setupTalentSidebar(char) {
  const presets = [
    { id: 'raid',   name: 'Raid',    icon: 'https://render.worldofwarcraft.com/us/icons/56/inv_misc_head_dragon_01.jpg',           desc: 'Single-target' },
    { id: 'mythic', name: 'Mythic+', icon: 'https://render.worldofwarcraft.com/us/icons/56/achievement_bg_wineos_underxminutes.jpg', desc: 'AoE / Dungeon' },
    { id: 'delves', name: 'Delves',  icon: 'https://render.worldofwarcraft.com/us/icons/56/inv_misc_map08.jpg',                     desc: 'Solo content' }
  ];

  const presetList = document.getElementById('build-presets');
  presetList.innerHTML = presets.map((p, i) => `
    <button class="build-preset ${i === 0 ? 'active' : ''}" data-build-type="${p.id}">
      <img src="${p.icon}" class="preset-icon-img" alt="${p.name}" />
      <div class="preset-info">
        <div class="preset-name">${p.name}</div>
        <div class="preset-desc">${p.desc}</div>
      </div>
    </button>
  `).join('');

  document.querySelectorAll('.build-preset').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.build-preset').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      _currentBuildType = btn.dataset.buildType;
      const cacheKey = `${char.class_slug}_${char.spec_slug}`;
      if (TALENT_TREE_CACHE[cacheKey]) {
        renderTalentTree(TALENT_TREE_CACHE[cacheKey], char);
      }
    });
  });

  // Copy Talents button ‚Äî copies current build string to clipboard
  const copyBtn = document.getElementById('copy-talents-btn');
  copyBtn.addEventListener('click', () => {
    const buildStr = TALENT_BUILDS[char.class_slug]?.[char.spec_slug]?.[_currentBuildType] || '';
    if (!buildStr) {
      const toast = document.getElementById('copy-talents-toast');
      toast.textContent = 'No build string set';
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
      return;
    }
    navigator.clipboard.writeText(buildStr).then(() => {
      const toast = document.getElementById('copy-talents-toast');
      toast.textContent = 'Copied!';
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }).catch(() => {
      // Fallback
      const ta = document.createElement('textarea');
      ta.value = buildStr;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      const toast = document.getElementById('copy-talents-toast');
      toast.textContent = 'Copied!';
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    });
  });
}

// ‚îÄ‚îÄ Render Full Talent Tree ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderTalentTree(treeData, char) {
  const view = document.getElementById('talent-tree-view');

  // Live-reload talent_builds.json for freshest data
  try {
    const buildsFile = _path.join(__dirname, 'talent_builds.json');
    if (_fs.existsSync(buildsFile)) {
      const raw = JSON.parse(_fs.readFileSync(buildsFile, 'utf-8'));
      const builds = {};
      for (const k of Object.keys(raw)) { if (!k.startsWith('_')) builds[k] = raw[k]; }
      TALENT_BUILDS = builds;
    }
  } catch(e) { /* ignore */ }

  const buildString = TALENT_BUILDS[char.class_slug]?.[char.spec_slug]?.[_currentBuildType] || '';

  const classNodes = treeData.class_nodes || [];
  const specNodes = treeData.spec_nodes || [];
  const heroTrees = treeData.hero_trees || [];

  // Decode (one flat sequence using full node ID list from tree data)
  const allNodeIds = treeData.all_node_ids || [];
  const { selections, activeHeroTreeName } = decodeBuildString(buildString, classNodes, specNodes, heroTrees, allNodeIds);

  // Split spec_nodes into hero display + pure spec
  const allHeroNodeIds = new Set();
  let activeHeroTree = null;
  // Collect all hero talent names (from all trees) to detect duplicate spec nodes
  const allHeroEntryNames = new Set();
  for (const ht of heroTrees) {
    if (!ht.nodes) continue;
    for (const n of ht.nodes) {
      allHeroNodeIds.add(n.id);
      for (const e of (n.entries || [])) if (e.name) allHeroEntryNames.add(e.name);
    }
    if (ht.name === activeHeroTreeName) activeHeroTree = ht;
  }
  if (!activeHeroTree && heroTrees.length > 0) activeHeroTree = heroTrees[0];
  let heroNodes = activeHeroTree ? [...activeHeroTree.nodes] : [];

  // Filter spec nodes: remove hero tree nodes by ID, and also remove spec nodes
  // that are name-duplicates of hero tree talents (e.g. Devourer DH has spec nodes
  // with identical names/positions as Void-Scarred hero nodes ‚Äî they're vestigial).
  const pureSpecNodes = specNodes.filter(n => {
    if (allHeroNodeIds.has(n.id)) return false;
    if (allHeroEntryNames.size > 0 && n.entries && n.entries.length > 0) {
      if (n.entries.every(e => allHeroEntryNames.has(e.name))) return false;
    }
    return true;
  });

  // Calculate flex from visible node position spans
  const visibleSpan = (nodes) => {
    if (!nodes || nodes.length === 0) return 1;
    const vis = nodes.filter(n => n.entries?.length > 0 && n.entries.some(e => e.name && e.name !== '?'));
    if (vis.length === 0) return 1;
    let min = Infinity, max = -Infinity;
    for (const n of vis) { min = Math.min(min, n.pos_x); max = Math.max(max, n.pos_x); }
    return Math.max(max - min, 1);
  };

  const classSpan = visibleSpan(classNodes);
  const heroSpan = heroNodes.length > 0 ? visibleSpan(heroNodes) : 0;
  const specSpan = visibleSpan(pureSpecNodes);

  let html = '<div class="talent-tree-container">';
  html += renderTreeSection(capitalize(char.class_slug), classNodes, selections, 'class', classSpan);
  if (heroNodes.length > 0) {
    html += renderTreeSection(activeHeroTree.name || 'Hero', heroNodes, selections, 'hero', heroSpan);
  }
  html += renderTreeSection(capitalize(char.spec_slug), pureSpecNodes, selections, 'spec', specSpan);
  html += '</div>';
  view.innerHTML = html;

  // Tooltips
  view.querySelectorAll('.talent-node').forEach(el => {
    const nodeId = parseInt(el.dataset.nodeId);
    const s = el.dataset.section;
    const list = s === 'class' ? classNodes : s === 'hero' ? heroNodes : pureSpecNodes;
    const node = list.find(n => n.id === nodeId);
    if (!node) return;
    el.addEventListener('mouseenter', e => showTalentTooltip(e, node, selections));
    el.addEventListener('mousemove', e => positionTooltip(e));
    el.addEventListener('mouseleave', () => hideTalentTooltip());
  });
}

// ‚îÄ‚îÄ Render One Tree Section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function renderTreeSection(label, nodes, selections, sectionId, flexWeight) {
  if (!nodes || nodes.length === 0) return '';
  flexWeight = flexWeight || 1;

  // Filter to visible nodes (skip gate/placeholder nodes with no usable entries)
  const visibleNodes = nodes.filter(n =>
    n.entries && n.entries.length > 0 &&
    n.entries.some(e => e.name && e.name !== '?')
  );
  if (visibleNodes.length === 0) return '';

  // Use raw_position (pos_x/pos_y) for layout ‚Äî these have proper sub-grid centering
  // unlike display_col which has only 4 values for hero trees (can't center a diamond)
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const n of visibleNodes) {
    minX = Math.min(minX, n.pos_x); maxX = Math.max(maxX, n.pos_x);
    minY = Math.min(minY, n.pos_y); maxY = Math.max(maxY, n.pos_y);
  }

  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;

  // Percentage positioning with edge padding
  const padX = 10, padY = 5;

  const nodePosMap = {};
  for (const n of nodes) {
    const pctX = padX + ((n.pos_x - minX) / rangeX) * (100 - 2 * padX);
    const pctY = padY + ((n.pos_y - minY) / rangeY) * (100 - 2 * padY);
    nodePosMap[n.id] = { pctX, pctY };
  }

  // SVG connection lines ‚Äî only draw where BOTH endpoints are in this section
  const sectionNodeIds = new Set(nodes.map(n => n.id));
  let svgLines = '';
  for (const node of nodes) {
    const target = nodePosMap[node.id];
    if (!target || !node.locked_by) continue;
    for (const depId of node.locked_by) {
      if (!sectionNodeIds.has(depId)) continue; // skip cross-section refs
      const source = nodePosMap[depId];
      if (!source) continue;
      const bothSelected = selections[depId] && selections[node.id];
      svgLines += `<line x1="${source.pctX}" y1="${source.pctY}" x2="${target.pctX}" y2="${target.pctY}" class="${bothSelected ? 'active' : ''}" />`;
    }
  }

  // Node HTML ‚Äî skip nodes with no usable entries (gate nodes) but they stay in the array for decoder
  let nodesHtml = '';
  for (const node of nodes) {
    const pos = nodePosMap[node.id];
    if (!pos) continue;
    // Skip gate/placeholder nodes with no entries or only "?" entries
    if (!node.entries || node.entries.length === 0 || 
        (node.entries.length === 1 && (!node.entries[0].name || node.entries[0].name === '?'))) {
      continue;
    }
    const sel = selections[node.id];
    const isSelected = !!sel;
    const entryIdx = (sel && sel.choice >= 0) ? sel.choice : 0;
    const entry = node.entries[entryIdx] || node.entries[0];

    const iconHtml = entry?.icon_url
      ? `<img src="${entry.icon_url}" alt="${entry?.name || ''}" loading="lazy" />`
      : `<span class="talent-node-letter">${(entry?.name || '?')[0]}</span>`;

    const rankBadge = node.max_ranks > 1
      ? `<span class="talent-rank-badge">${sel ? sel.rank : 0}/${node.max_ranks}</span>`
      : '';

    nodesHtml += `
      <div class="talent-node ${isSelected ? 'selected' : ''}"
           data-type="${node.type}" data-node-id="${node.id}" data-section="${sectionId}"
           style="left:${pos.pctX}%;top:${pos.pctY}%">
        <div class="talent-node-inner">
          ${iconHtml}
        </div>
        ${rankBadge}
      </div>`;
  }

  return `
    <div class="talent-section" data-section="${sectionId}" style="flex:${flexWeight} 1 0;min-width:0;">
      <div class="talent-section-label">${label}</div>
      <div class="talent-grid">
        <svg class="talent-connections" viewBox="0 0 100 100" preserveAspectRatio="none">${svgLines}</svg>
        ${nodesHtml}
      </div>
    </div>`;
}

function capitalize(str) {
  if (!str) return '';
  return str.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}


function loadVault(char) {
  const container = document.getElementById('vault-content');
  container.innerHTML = '<div class="vault-placeholder">Vault tracking coming in next update...</div>';
}

function closeDetail() {
  document.getElementById('detail-overlay').classList.remove('open');
  detailIndex = null;
}

function updateResetTimers() {
  ['daily', 'weekly'].forEach(type => {
    const { text, cls } = formatTimeUntil(getNextReset(type));
    const el = document.getElementById(`reset-${type}`);
    el.textContent = text;
    el.className   = 'reset-value ' + cls;
  });
}
setInterval(() => { if (detailIndex !== null) updateResetTimers(); }, 60000);

// ‚îÄ‚îÄ Equipment panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function loadEquipment(char) {
  const loadingEl = document.getElementById('armory-loading');
  
  // If we have cached equipment, show it immediately
  if (char.equipment && char.equipment.length > 0) {
    renderEquipment(char.equipment);
    loadingEl.style.display = 'none';
    // Trigger background refresh if cache is stale
    sendToPython(`GET_EQUIPMENT:${char.region}:${char.realm}:${char.name}`);
  } else {
    // No cache - show loading spinner and notification
    document.getElementById('equip-left').innerHTML  = '';
    document.getElementById('equip-right').innerHTML = '';
    loadingEl.style.display = 'flex';
    _equipFetchInProgress = true;
    showFetchNotify('equipment', `Fetching equipment for ${capitalize(char.name)}‚Ä¶`);
    sendToPython(`GET_EQUIPMENT:${char.region}:${char.realm}:${char.name}`);
  }
}

function renderEquipment(items) {
  document.getElementById('armory-loading').style.display = 'none';
  // Map slot ‚Üí item data
  const bySlot = {};
  items.forEach(item => { bySlot[item.slot] = item; });

  renderEquipCol(document.getElementById('equip-left'),  EQUIP_LEFT,  bySlot, 'left');
  renderEquipCol(document.getElementById('equip-right'), EQUIP_RIGHT, bySlot, 'right');
}

function showEquipmentRefreshing() {
  const indicator = document.getElementById('equip-refresh-indicator');
  if (indicator) {
    indicator.style.display = 'flex';
    setTimeout(() => { indicator.style.display = 'none'; }, 3000);
  }
}

function renderEquipCol(container, slots, bySlot, side) {
  container.innerHTML = '';
  slots.forEach(slot => {
    const item  = bySlot[slot];
    const label = SLOT_LABEL[slot] || slot;
    const row   = document.createElement('div');
    row.className = `equip-row equip-row-${side}`;

    if (item) {
      const color   = QUALITY_COLOR[item.quality] || QUALITY_COLOR.COMMON;
      const iconHtml = item.icon_url
        ? `<div class="equip-icon" style="background-image:url('${item.icon_url}');border-color:${color}20;"></div>`
        : `<div class="equip-icon equip-icon-empty"></div>`;
      const nameHtml = `<div class="equip-info"><div class="equip-name" style="color:${color}">${item.name}</div><div class="equip-ilvl">${item.ilvl}</div></div>`;

      row.innerHTML = side === 'left'
        ? nameHtml + iconHtml
        : iconHtml + nameHtml;
    } else {
      const emptyHtml = `<div class="equip-icon equip-icon-empty"></div><div class="equip-info"><div class="equip-name equip-empty-slot">${label}</div></div>`;
      row.innerHTML = side === 'left'
        ? `<div class="equip-info"><div class="equip-name equip-empty-slot">${label}</div></div><div class="equip-icon equip-icon-empty"></div>`
        : emptyHtml;
    }
    container.appendChild(row);
  });
}

// ‚îÄ‚îÄ Activities ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function toggleActivity(charIdx, activityName, isDone) {
  const char = characters[charIdx];
  if (!char?.activities[activityName]) return;
  char.activities[activityName].status = isDone ? 'completed' : 'available';
  updateCardPip(charIdx, activityName, isDone);
  sendToPython(`TOGGLE_ACTIVITY:${char.name}:${char.realm}:${activityName}`);
}

// ‚îÄ‚îÄ Delete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function openDeleteModal(idx) {
  pendingDelete = idx;
  const char = characters[idx];
  document.getElementById('delete-modal-msg').textContent =
    `Remove ${char.name} from ${char.realm}? This cannot be undone.`;
  document.getElementById('delete-modal').classList.add('open');
}

document.getElementById('delete-cancel').addEventListener('click', () => {
  document.getElementById('delete-modal').classList.remove('open');
  pendingDelete = null;
});

document.getElementById('delete-confirm').addEventListener('click', () => {
  if (pendingDelete === null) return;
  const char = characters[pendingDelete];
  sendToPython(`DELETE_CHARACTER:${char.name}:${char.realm}`);
  if (detailIndex === pendingDelete) closeDetail();
  characters.splice(pendingDelete, 1);
  pendingDelete = null;
  document.getElementById('delete-modal').classList.remove('open');
  renderGrid();
  showToast(`${char.name} removed`);
});

// ‚îÄ‚îÄ Realm autocomplete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function showRealmSuggestions(query) {
  const region   = document.getElementById('input-region').value;
  const realms   = realmCache[region] || [];
  const dropdown = document.getElementById('realm-dropdown');
  if (!query || !realms.length) { dropdown.classList.remove('open'); return; }

  const matches = realms.filter(r => r.toLowerCase().startsWith(query.toLowerCase())).slice(0, 7);
  if (!matches.length) { dropdown.classList.remove('open'); return; }

  dropdown.innerHTML = matches
    .map(r => `<div class="autocomplete-item">${r}</div>`)
    .join('');
  dropdown.querySelectorAll('.autocomplete-item').forEach(item => {
    item.addEventListener('mousedown', e => {
      e.preventDefault();
      document.getElementById('input-realm').value = item.textContent;
      dropdown.classList.remove('open');
    });
  });
  dropdown.classList.add('open');
}

function loadRealms(region) {
  if (!realmCache[region]) sendToPython(`GET_REALMS:${region}`);
}

const realmInput  = document.getElementById('input-realm');
const inputRegion = document.getElementById('input-region');

realmInput.addEventListener('input',  () => showRealmSuggestions(realmInput.value));
realmInput.addEventListener('blur',   () => setTimeout(() => document.getElementById('realm-dropdown').classList.remove('open'), 150));
inputRegion.addEventListener('change', e => { loadRealms(e.target.value); document.getElementById('realm-dropdown').classList.remove('open'); });

// ‚îÄ‚îÄ Add Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const addModal  = document.getElementById('add-modal');
const inputName = document.getElementById('input-name');

document.getElementById('add-btn').addEventListener('click', () => {
  if (_talentFetchInProgress || _equipFetchInProgress) {
    showToast('Wait for data to finish fetching first');
    return;
  }
  addModal.classList.add('open');
  loadRealms(inputRegion.value);
  inputName.focus();
});

function closeAddModal() {
  addModal.classList.remove('open');
  inputName.value  = '';
  realmInput.value = '';
}

document.getElementById('modal-cancel').addEventListener('click', closeAddModal);
addModal.addEventListener('click', e => { if (e.target === addModal) closeAddModal(); });

document.getElementById('modal-submit').addEventListener('click', () => {
  const name   = inputName.value.trim();
  const realm  = realmInput.value.trim();
  const region = inputRegion.value;
  if (!name) { inputName.focus(); return; }

  const btn = document.getElementById('modal-submit');
  btn.textContent = 'Searching‚Ä¶';
  btn.disabled    = true;

  if (realm) {
    showToast(`Looking up ${name} on ${realm} (${region.toUpperCase()})‚Ä¶`);
    sendToPython(`ADD_CHARACTER:${region}:${realm}:${name}`);
  } else {
    showToast(`Scanning all ${region.toUpperCase()} realms for ${name}‚Ä¶ (may take a few minutes)`);
    sendToPython(`AUTO_ADD:${region}:${name}`);
  }
  closeAddModal();
  setTimeout(() => { btn.textContent = 'Search & Add'; btn.disabled = false; }, 500);
});

inputName.addEventListener('keydown', e => { if (e.key === 'Enter') document.getElementById('modal-submit').click(); });

// ‚îÄ‚îÄ Other modals ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

document.getElementById('detail-close').addEventListener('click', closeDetail);
document.getElementById('detail-overlay').addEventListener('click', e => {
  if (e.target === document.getElementById('detail-overlay')) closeDetail();
});

// Tab switching
document.querySelectorAll('.detail-tab').forEach(btn => {
  btn.addEventListener('click', () => {
    const char = characters[detailIndex];
    if (char) switchTab(btn.dataset.tab, char);
  });
});

document.getElementById('menu-info').addEventListener('click', () => document.getElementById('info-modal').classList.add('open'));
document.getElementById('menu-settings').addEventListener('click', () => document.getElementById('settings-modal').classList.add('open'));

document.getElementById('info-close').addEventListener('click', () => document.getElementById('info-modal').classList.remove('open'));
document.getElementById('settings-close').addEventListener('click', () => document.getElementById('settings-modal').classList.remove('open'));

document.getElementById('info-modal').addEventListener('click', e => {
  if (e.target === document.getElementById('info-modal'))
    document.getElementById('info-modal').classList.remove('open');
});

document.getElementById('settings-modal').addEventListener('click', e => {
  if (e.target === document.getElementById('settings-modal'))
    document.getElementById('settings-modal').classList.remove('open');
});

document.getElementById('github-link').addEventListener('click', e => {
  e.preventDefault();
  if (ipcRenderer) ipcRenderer.send('open-external', e.currentTarget.href);
  else window.open(e.currentTarget.href, '_blank');
});

// Theme toggle
const applyTheme = (theme) => {
  document.documentElement.setAttribute('data-theme', theme);
  document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.theme === theme);
  });
  try {
    localStorage.setItem('innkeeper-theme', theme);
  } catch (e) {}
};

document.querySelectorAll('.theme-btn').forEach(btn => {
  btn.addEventListener('click', () => applyTheme(btn.dataset.theme));
});

// Load saved theme
try {
  const saved = localStorage.getItem('innkeeper-theme');
  if (saved) applyTheme(saved);
} catch (e) {}

// ‚îÄ‚îÄ Electron IPC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

if (ipcRenderer) {
  document.getElementById('btn-close').addEventListener('click', () => ipcRenderer.send('window-close'));
  document.getElementById('btn-min').addEventListener('click',   () => ipcRenderer.send('window-minimize'));
  document.getElementById('btn-max').addEventListener('click',   () => ipcRenderer.send('window-maximize'));

  ipcRenderer.on('from-python', (event, raw) => {
    try {
      const data = JSON.parse(raw);

      if (Array.isArray(data)) { characters = data; renderGrid(); return; }

      if (data.status === 'added') {
        characters.push(data.character);
        renderGrid();
        showToast(`${data.character.name} added!`);
      } else if (data.status === 'not_found') {
        showToast('Character not found ‚Äî check name and realm', true);
      } else if (data.status === 'error') {
        showToast(data.message || 'Something went wrong', true);
      } else if (data.status === 'realms') {
        realmCache[data.region] = data.realms;
        if (data.region === inputRegion.value) showRealmSuggestions(realmInput.value);
      } else if (data.status === 'equipment') {
        _equipFetchInProgress = false;
        hideFetchNotify('equipment');
        renderEquipment(data.items);
      } else if (data.status === 'equipment_refreshing') {
        showEquipmentRefreshing();
      } else if (data.status === 'talent_tree') {
        // Received talent tree data from Blizzard API
        _talentFetchInProgress = false;
        hideFetchNotify('talents');
        if (window._talentLoadTimeout) { clearTimeout(window._talentLoadTimeout); window._talentLoadTimeout = null; }
        window._talentRetried = false;
        const cacheKey = `${data.class_slug}_${data.spec_slug}`;
        TALENT_TREE_CACHE[cacheKey] = data.tree;
        const cn = (data.tree.class_nodes||[]).length;
        const sn = (data.tree.spec_nodes||[]).length;
        const hn = (data.tree.hero_trees||[]).map(h => `${h.name||'?'}(${(h.nodes||[]).length})`).join(', ');
        console.log(`‚úì Talent tree cached: ${cacheKey} | ${cn} class nodes, ${sn} spec nodes, hero: [${hn}]`);
        // If talent tab is currently open for this class/spec, render it
        if (_currentTalentChar &&
            _currentTalentChar.class_slug === data.class_slug &&
            _currentTalentChar.spec_slug === data.spec_slug) {
          renderTalentTree(data.tree, _currentTalentChar);
        }
      } else if (data.status === 'talent_tree_error') {
        if (window._talentLoadTimeout) { clearTimeout(window._talentLoadTimeout); window._talentLoadTimeout = null; }
        console.error(`‚úó Talent tree error: ${data.class_slug}/${data.spec_slug}: ${data.message}`);
        // Auto-retry once before showing error to user
        if (!window._talentRetried) {
          window._talentRetried = true;
          console.log('‚Üª Auto-retrying talent tree fetch‚Ä¶');
          setTimeout(() => {
            sendToPython(`FETCH_TALENT_TREE:${_currentTalentChar?.region || 'eu'}:${data.class_slug}:${data.spec_slug}`);
          }, 1500);
          return;
        }
        window._talentRetried = false;
        _talentFetchInProgress = false;
        hideFetchNotify('talents');
        // If talent tab is currently open for this class/spec, show error
        if (_currentTalentChar &&
            _currentTalentChar.class_slug === data.class_slug &&
            _currentTalentChar.spec_slug === data.spec_slug) {
          const view = document.getElementById('talent-tree-view');
          if (view) {
            const msg = (data.message || 'Unknown error').replace(/</g, '&lt;');
            view.innerHTML = `
              <div class="talent-empty">
                <p style="margin-bottom:12px;font-size:13px;">Could not load talent tree</p>
                <div style="background:rgba(0,0,0,0.3);border:1px solid rgba(200,80,80,0.2);border-radius:6px;padding:12px 16px;margin-bottom:16px;max-width:500px;width:100%;text-align:left;">
                  <div style="font-size:9px;text-transform:uppercase;letter-spacing:0.1em;color:rgba(200,80,80,0.6);margin-bottom:6px;">Error Details</div>
                  <div style="font-size:11px;color:var(--text-realm);line-height:1.6;word-break:break-word;">${msg}</div>
                </div>
                <button class="btn btn-primary" id="talent-retry-btn">Retry</button>
              </div>`;
            document.getElementById('talent-retry-btn')?.addEventListener('click', () => {
              loadTalents(_currentTalentChar);
            });
          }
        }
      } else if (data.status === 'talent_builds_loaded' && data.builds) {
        // Build strings loaded from talent_builds.json
        TALENT_BUILDS = data.builds;
        const classes = Object.keys(data.builds).filter(k => !k.startsWith('_'));
        console.log(`‚úì Build strings loaded. Classes: [${classes.join(', ')}]`);
        for (const cls of classes) {
          if (typeof data.builds[cls] === 'object') {
            for (const spec of Object.keys(data.builds[cls])) {
              const types = data.builds[cls][spec];
              if (typeof types === 'object') {
                for (const [t, str] of Object.entries(types)) {
                  console.log(`  ${cls}/${spec}/${t}: ${str ? str.substring(0, 30) + '‚Ä¶ (' + str.length + ' chars)' : '(empty)'}`);
                }
              }
            }
          }
        }
        // Re-render talent tree if already open (builds may have arrived after initial render)
        if (_currentTalentChar) {
          const ck = `${_currentTalentChar.class_slug}_${_currentTalentChar.spec_slug}`;
          if (TALENT_TREE_CACHE[ck]) {
            console.log('‚Üª Re-rendering talent tree with updated build strings');
            renderTalentTree(TALENT_TREE_CACHE[ck], _currentTalentChar);
          }
        }
      }
    } catch (e) {
      console.error('from-python parse error:', e);
    }
  });
}

renderGrid();
</script>
</body>
</html>